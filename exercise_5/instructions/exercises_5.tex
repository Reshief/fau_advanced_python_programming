\documentclass[]{erlangen-problemset}
%\documentclass[a4paper]{scrartcl}
\usepackage{amsmath} %the recommended functionalities are align and gather for several equations (split allows arranging by hand; gather centers the equations), split for one equation over several lines (for both use '&' for the alignment); and multline for long expressions, which puts the first line left-aligned and the last line right-aligned! 
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{url}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{color}
\usepackage{csquotes}
\usepackage{tensor} %e.g. \tensor[^a_b^c_d]{M}{^a_b^c_d}
%\usepackage{breqn} %better use a function from the amsmath package
\usepackage{easytable} %more options to produce tables!
%\usepackage[backend=biber,style=chem-angew,sorting=none, maxbibnames = 99]{biblatex}
\usepackage{bm} %fat text in formulas
\usepackage{afterpage}
\usepackage[toc,page]{appendix}
%\usepackage[usenames, dvipsnames]{color}
\usepackage{enumitem}
\usepackage{braket}
\usepackage{subfiles}
\usepackage{siunitx}

\newcommand{\del}{\partial}
\newcommand{\eqbox}[1]{\mbox{\boxed{#1}}}
\newcommand{\textitbf}[1]{\textbf{\textit{#1}}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\green}[1]{\textcolor{green}{#1}}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}
\newcommand{\op}[1]{\hat{\textbf{#1}}}
\renewcommand{\d}{\mathrm{d}}
\newcommand{\kb}{k_\text{B}}
\newcommand{\ev}[1]{\langle{#1}\rangle}


%Penalties
\widowpenalty10000
\clubpenalty10000

\setcounter{problemset}{5}

%\title{{\Large Advanced Python for Research Projects} \\[0.3cm] 
%Exercise sheet 5: Parallelization}

\title{{\Large Advanced Python for Research Projects} \\[0.3cm] 
Exercise sheet 5: Git version control}

\begin{document}
%\maketitle 


%\begin{problem}[title={Setting up a git repository manually}]
%\noindent
%\Question 
%\end{problem}

\begin{problem}[title={Some git nomenclature}]
To be able to better understand git, its usual errors and use cases, it is important to know a few terms of the nomenclature surrounding git. 
Familiarize yourself with the following terms and potential differences:
\noindent
\Question Plumbing vs. porcellain commands: What is the difference and which of the command we have talked about in the lecture are part of which group?
\Question Blob vs. Tree vs. Commit: What do these terms refer to, how do they correspond to common terms in computer use and how does git use these in its usual version control workflow?
\Question Working copy/directory vs. Index/Staging area vs. Repository vs. Remote: 
How do these different terms relate to each other? 
In which order do changes to files flow through these stages of storage/version control?
\Question Head vs. Branch vs. Tag vs. Release: What is the difference between these terms (if there is one) and how do they relate to each other?
\Question What is the difference in effect between a \texttt{git pull} and a \texttt{git fetch} call?
\end{problem}

\begin{problem}[title={Setting up a git repository the simple way}]
In the lecture, we have illustrated the details of creating a git repository manually.
In practice, you will rarely have to manually set up object storage, tree writes or a manual commit yourself. 
Here, we instead want to set up a repository in a way that you may go about it in your scientific work through porcellain commands.
\noindent
\Question Go to the folder of the previous exercise, where you set up the package structure for your pypi package project to be installed to a local user. 
We now want to put that folder under version control and create a git project in an existing folder structure. 
You can do this, by calling \texttt{git init <directory>}, where the \texttt{<directory>} option refers to the folder where you want to create the git repository. 
If the folder does not exist, it will be created first. 
As we want to create the project in an existing folder, open your terminal in the root of the existing package project and initialize the git repository for the local directory denoted by the relative specifier \texttt{.} to indicate the git repository should be created here. 
Git will then automatically create the \texttt{.git} folder structure and a main or master branch (depending on your version of git).
\Question We soon want to add the different files from the previous exercise to this repository, but first, we want to initialize the appropriate branches for git workflows.
Let's create a \texttt{develop} branch using the \texttt{git branch develop} command.
Then confirm whether you are still on the main or on the develop branch using the \texttt{git branch} command. 
If you are not on the develop branch, use \texttt{git checkout <branch>} to switch to the correct branch.
If we opt for a very fine-granular branch setup, we may now create a new branch for the initialization of the project, but in most cases, the initialization can just be done on the develop branch. 
\Question On the develop branch, we first want to avoid adding temporary files generated by python or other tools. 
Let us create a \texttt{.gitignore} file in the root of the project and add the appropriate contents for a python project. 
You can generate a \texttt{.gitignore} file for example with a generator like \url{https://www.toptal.com/developers/gitignore} and specify the Python language. 
The resulting contents can then be copied into your local \texttt{.gitignore} file. 
Add the \texttt{.gitignore} file to the git index with a \texttt{git add .gitignore} call. 
\Question You should now check, which files git registers as new. User \texttt{git status} to get a list of new files and directories git has recognized. 
You should see the \texttt{.py} files in the \texttt{fauap\_advanced\_functions} folder, the \texttt{.py} files in the \texttt{tests} directory and the documentation files in the \texttt{docs} directory. 
Additionally, meta files in the root directory for the project (like \texttt{Readme} and \texttt{pyproject.toml}) and the \texttt{setup.py} file. 
Make sure you see no folders anmed like \texttt{__pycache__} or files witht a \texttt{.pyc} suffix. Those are temporary files generated by python and should not be added to a git repository. 
Other programming languages have different suffixes for temporary files that need to be listed in \texttt{.gitignore} so make sure to generate an appropriate \texttt{.gitignore} file for your respective project. 
If you still see those temporary files in \texttt{git status}, check the spelling of your \texttt{.gitignore} file, look if there are rules in there to exempt those temporary files and, if they are missing, add such rules. 
Then, once you only see appropriate files in \texttt{git status}, add the files of your project. 
We recommend at least going folder-by-folder as \texttt{git add --all} often adds unwanted files. 
After adding all files, check the status again to see, wich files are now part of the index. 
If there are temporary files that have been accidentally added, remove them via the \texttt{git reset} or the \texttt{git restore} commands. 
The \texttt{git status} overview will give you the appropriate instructions for how to remove them from the index/staging area. 
\Question We now want to create our initial commit of the project to git, so check that all relevant files of the project are part of your staging area in \texttt{git status}.
If there are some secrets like passwords written somewhere in your project files, you should make sure, that none of those parts of the code are part of your index before committing. 
Otherwise, it is usually hard to get rid of those entries again. 
Once you are sure, that you only have the relevant files, create an initial commit on the \texttt{develop} branch with an appropriate commit message. 
Commit messages are usually written in present tense, like "Add functionality to write files" or "Fix bug preventing file output on a Tuesday". 
Some projects opt for a style more along the lines of "<File or topic>: <message>" to make it easier to see, in which aspect a commit alters a project from the topic or filename before the colon. 
For an initial commit, it may suffice to write "Initialize project with existing package setup from previous exercise".
(It is also common to not add fullstops at the ends of commit messages, but your project is yours to govern. Just make it consistent and write down such rules, e.g. in a \texttt{Readme} or in a \texttt{CONTRIBUTIONS} file.)
\Question look at your newly created commit either via \texttt{git log} or via \texttt{tig} and confirm all files have been added. 
You can also confirm this with \texttt{git status} if the files in your project are no longer listed as new/added or modified.
\end{problem}

\begin{problem}[title={Dealing with remotes}]
\noindent
\Question 
\end{problem}

\begin{problem}[title={Setting up a git workflow: Adding functionality through branches}]
\noindent
\Question 
\end{problem}

%\maketitle 




\end{document}
